Today: review for final exam 
Wed/Fri: work time / checkoff for milestone 12


////////////////////////////

General announcements:
- NO late work accepted after Friday, May 9 (includes milestones and tutorials)
- Milestone 12 must be checked off in class or office hours (not Canvas)
- Website design competition - submit new release by Friday, May 9
    winner gets gift card to a burger/ice cream place 
    (Dairy Queen? Freddy's? Culver's?)



Tutorial: POST requests and JSON (due today)

Milestone 12 (due Friday, May 9)



/////////////////////////////////

Optional final.
    1:30 section: Tuesday, May 13 11:50 am - 1:40 pm
    2:30 section: Thursday, May 15 4:10-6:00 pm 

Format.
    Paper-based, closed notes, closed computers.
    Multiple choice followed by open-ended.
    Similar format as midterms, but slightly longer


--> be familiar with all vocabulary terms

--> I highly recommend reviewing exams 1 and 2 and their practice exams

/////////////////////////////////////

For open-ended:
- Implementing a class, including fields/properties/methods/constructors  
- Creating and using objects
- Enforcing the bounds of a property - would need private backing field

- Writing and implementing an interface
- Using inheritance and abstract classes

- Drawing and interpreting UML diagrams

- Implementing INotifyPropertyChanged - declaring the event, invoking as needed

- Events, including custom events, custom event arguments, invoking events, 
    attaching event handlers to events, and using events to send messages 
    between objects

- Writing Fact and Theory xUnit tests
    (Equals, True, False, Contains, PropertyChanged)    

- LINQ queries for filtering
    Where, OrderBy, OrderByDescending


--> No questions on XAML, Razor Pages, CSS, HTML


//////////////////////////////////

General review:


Encapsulation --> going from a problem statement to class definitions

Defining a class -->
    when do we need a constructor?
        if I want to require initial values for properties/fields
        when creating the object, would have those as params to constructor

    when do we need a static constructor? if we want to initialize things
        before anything else in the class is used
       

Polymorphism --> 
    many forms
    IceCreamCone - possible types? IceCream, IMenuItem, IceCreamCone,
        object, INotifyPropertyChanged

        INotifyPropertyChanged c = new IceCreamCone();



Inheritance --> 
    example? Burger, ClassicCheeseburger (and all the others)
    why? common properties, and common operations (like calories)
    different names for each class?
        Burger: parent class, ancestor, super class, base class
        ClassicCheeseburger: child class, descendent, sub class, derived class

    how to implement methods/properties differently?
        parent: use "virtual", or "abstract" (only if the parent class is abstract)
        child: use "override"

    how do constructors work?
        Child c = new Child();
            first code executed is in the top parent
            (then the next ancestor down, if any)
            finally child constructor

    rules when extending a class?

        public abstract class Parent {
            public abstract void Something();
        }

        public abstract class Child : Parent {
            //inherit public abstract void Something();
        }

        //OR, could be non-abstract and override all abstract from parent


    public class Animal {
        private string _name;

        public Animal(string n) {
            _name = n;
        }

        public void Talk {
            Console.WriteLine("words");
            Console.WriteLine(_name);
        }
    }

    public class Dog: Animal {
        //is this OK?
        public Dog() : base("Fido") {}
    }

    //is this OK?
    public class Collie: Dog {
        //automatically: public Collie() : base()
    }


Are these OK?
    Animal a = new Dog();       //Yes! Dogs are Animals
    Dog d = a;                  //NO! Would need an explicit cast

    Dog c = new Collie();        //YES! Collies are Dogs
    c.Talk();                   //YES! Prints "words", "Fido"




Interfaces - why? blueprint, list of requirements for a class


Abstract classes -->
    how different from interfaces?
        abstract class can have a constructor
        visibilities
        abstract classes can have fields, fully implemented methods/properties
        
    
    rules when extending an abstract class?

    public abstract class Example {
        public abstract void DoStuff();
    }

    public class Child : Example {
       //what do we have to do?
    }

    what does an abstract class need to do when implementing an interface?


Events
Data binding
MVVM - model, view, viewmodel
    in WPF, view model is the DataContext of the view
            view model has access to model
            model has access to nothing

Field --> can we override? NO! (only properties/methods)
Method
Property --> difference from field? types of accessors? 
    change get/set visibility
    can have derived properties that compute the value (like a method)

public
protected --> where visible? own class, children
private
static --> how do we use?

Implicit casting --> when?

Explicit casting --> different ways. When is it needed?


virtual --> places used? behavior?

abstract --> places used? behavior?

override --> when can we say this?

as - what kind of thing is this? 

is - what kind of thing is this? 


enum --> know how to declare, use

/////////////////////////

public interface IInterface {
    void Method1(params);
}

public abstract class AbstractClass {
    public void FinishedMethod() {
        Console.WriteLine("is done");
    }

    public virtual void Method2() {
        Console.WriteLine("parent");
    }

    public abstract void AbstractMethod(params);
}

public class ChildClass : AbstractClass, IInterface {
    public override void AbstractMethod(params) {
        Console.WriteLine("code");
    }

    public override void Method2() {
        Console.WriteLine("child");
    }

    public void Method1(params) {
        Console.WriteLine("done");
    }
}

AbstractClass c = new ChildClass();
c.Method2(); // what happens?


<-- is the word "override" required for AbstractMethod?


ChildClass c = new ChildClass();
c.FinishedMethod(); //can we do this?

//////////////////

Look at UML of student information.

--> assume _students is already initialized

--> complete FilterByStanding

public IEnumerable<Student> FilterByStanding(Standing s) {
    return _students.Where(item => item.CurStanding == s);
}


--> HonorRoll (3.5 and up, srs only)

public IEnumerable<Student> HonorRoll {
    get {
        return FilterByStanding(Standing.Senior).Where(item => item.GPA >= 3.5);
    }
}

/////////////////

--> see pie UML


Add the appropriate UML associations to the diagram. 
We want to indicate that PaleozoicPie implements INotifyPropertyChanged and IOrderItem.


Write the PaleozoicPie class definition.
- Description should be the filling followed by "Paleozoic Pie." 
- A Paleozoic Pie is $3.00 plus an additional $1 when served with ice cream (a la mode)
- Instructions should include "Hot" if the pie is hot and 
    "A La Mode" if the pie is served a la mode.


--> know how to implement INotifyPropertyChanged for a collection!

(if time, how would it work for PieSampler if it had a TotalPrice property
    that was 75% of total pie price?)

public class PieSampler : INotifyPropertyChanged {
    public event PropertChangedEventHandler? PropertyChanged;

    private List<PaleozoicPie> _pies = new();

    public List<PaleozoicPie> Pies => _pies;

    public decimal TotalPrice {
        get {
            decimal sum = 0.0m;
            foreach (PaleozoicPie p in _pies) {
                sum += p.Price;
            }

            return sum * 0.75m;
        }
    }

    private void HandlePieChange(object sender, PropertyChangedEventArgs e) {
        if (e.PropertyName == "Price") {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(TotalPrice)));
        }
    }

    public void AddPie(PaleozoicPie p) {
        _pies.Add(p);
        p.PropertyChanged += HandlePieChange;
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(TotalPrice)));
    }
} 